{% extends base.html %}

{% block script %}

<script src="/static/js/three/Three.js"></script>
<script src="/static/js/three/Detector.js"></script>
<script src="/static/js/three/THREEx.KeyboardState.js"></script>
<script src="/static/js/three/THREEx.FullScreen.js"></script>
<script src="/static/js/three/THREEx.WindowResize.js"></script>
<script src="/static/js/three/OrbitControls.js"></script>
<script src="/static/js/three/Stats.js"></script>
<script src="/static/js/three/hand_data.js"></script>
<script src="/static/js/three/setup.js"></script>
<script src="/static/js/three/geometry.js"></script>
<script src="/static/js/three/GRS.js"></script>


<script>
	// Macro objects
	var container, scene, camera, renderer, controls, stats
	var keyboard = new THREEx.KeyboardState()	
	var clock = new THREE.Clock()
	var light, ambientLight
	var car,cylinder,group,pivot,tick=0.02
	var rotation = {
		heading : 0,
		pitch : 0,
		roll : 0
	}

	var sphere, cylinder
	
	function init(){

		setup();
		///// Gemetry ////


	
		thumb = []
		scale = GRS.scale
		

		// Init hand		
		height = GRS.wrist.position.y 
		// Wrist
		GRS.wrist.object = new THREE.Mesh(wristSphereGeometry,sphereMaterial)
		GRS.wrist.object.position.set(GRS.wrist.position.x,GRS.wrist.position.y,GRS.wrist.position.z)
		// scene.add(GRS.wrist.object)

		
		
		// Init joints
		fingers = ["thumb","index","middle","ring","pinky"]
		for(j=0;j<fingers.length;j++)
		{
			finger = fingers[j]
			var tmp = jQuery.extend(true, {}, joint_template)
			tmp.position.y = height
			d = GRS[finger].wrist * scale
			//Heading
			tmp.position.x = GRS.wrist.position.x + d * Math.sin(GRS[finger].wrist_angle + GRS.wrist.heading) 
			tmp.position.z = GRS.wrist.position.z + d * Math.cos(GRS[finger].wrist_angle + GRS.wrist.heading) 
			tmp.spin.heading = GRS[finger].finger_angle + GRS.wrist.heading
			
			//Pitch
			dx = tmp.position.x - GRS.wrist.position.x 
			tmp.position.x = GRS.wrist.position.x + dx * Math.cos(GRS.wrist.pitch)
			tmp.position.y = GRS.wrist.position.y + d * Math.sin(GRS.wrist.pitch)
			tmp.spin.pitch = GRS.wrist.pitch

			tmp.object = new THREE.Mesh(tipSphereGeometry,sphereMaterial)
			tmp.object.position.set(tmp.position.x,tmp.position.y,tmp.position.z)
			
			GRS[finger].joints.push(tmp)
			// scene.add(GRS[finger].joints[0].object)

			bones = ["metacarpal","proximal","intermediate","distal"]
			var curr_joint = 0
			for(i=0;i<bones.length;i++)
			{
				// Joint
				if(i==2 && finger == "thumb")
					continue
				curr_joint++
				var tmp = jQuery.extend(true, {}, joint_template)
				tmp.position.y = height
				d = GRS[finger][bones[i]] * scale
				
				// Heading
				tmp.position.x = GRS[finger].joints[curr_joint-1].position.x + d * Math.sin(GRS[finger].joints[curr_joint-1].spin.heading)
				tmp.position.z = GRS[finger].joints[curr_joint-1].position.z + d * Math.cos(GRS[finger].joints[curr_joint-1].spin.heading)
				tmp.spin.heading = GRS[finger].joints[curr_joint-1].spin.heading

				//Pitch
				
				dx = tmp.position.x - GRS[finger].joints[curr_joint-1].position.x 
				tmp.position.x = GRS[finger].joints[curr_joint-1].position.x + dx * Math.cos(GRS[finger].joints[curr_joint-1].spin.pitch)
				tmp.position.y = GRS[finger].joints[curr_joint-1].position.y + d  * Math.sin(GRS[finger].joints[curr_joint-1].spin.pitch)
				tmp.spin.pitch   = GRS[finger].joints[curr_joint-1].spin.pitch
				
				tmp.object = new THREE.Mesh(tipSphereGeometry, sphereMaterial)
				tmp.object.position.set(tmp.position.x,tmp.position.y,tmp.position.z)
				

				GRS[finger].joints.push(tmp)
				delete tmp
				// scene.add(GRS[finger].joints[curr_joint].object)

				// Bone
				var tmp = jQuery.extend(true, {}, joint_template)
				var curr_geo = new THREE.CylinderGeometry(4,4,d,32,32,false)
				curr_geo.applyMatrix( new THREE.Matrix4().makeTranslation( 0, d / 2, 0 ) );
				curr_geo.applyMatrix( new THREE.Matrix4().makeRotationX(	 THREE.Math.degToRad( 90 ) ) );

				var joint1 = GRS[finger].joints[curr_joint]
				var joint2 = GRS[finger].joints[curr_joint-1]
				tmp.position.x = joint1.position.x
				tmp.position.y = joint1.position.y
				tmp.position.z = joint1.position.z

				tmp.object = new THREE.Mesh(curr_geo,cylinderMaterial)
				tmp.object.position.copy(joint1.position)
				tmp.object.lookAt(joint2.position)
				GRS[finger].bones.push(tmp)
				
			}
		}
		draw_hand()
		// GRS.wrist.position.x = -300
		redraw()
	
	}

function redraw()
{
	GRS.wrist.object.position.set(GRS.wrist.position.x,GRS.wrist.position.y,GRS.wrist.position.z)
	fingers = ["thumb","index","middle","ring","pinky"]
	for(j=0;j<fingers.length;j++)
	{
		finger = fingers[j]
		d = GRS[finger].wrist * scale
		//Heading
		GRS[finger].joints[0].position.x = GRS.wrist.position.x + d * Math.sin(GRS[finger].wrist_angle + GRS.wrist.heading) 
		GRS[finger].joints[0].position.z = GRS.wrist.position.z + d * Math.cos(GRS[finger].wrist_angle + GRS.wrist.heading) 
		GRS[finger].joints[0].spin.heading = GRS[finger].finger_angle + GRS.wrist.heading
		
		//Pitch
		dx = GRS[finger].joints[0].position.x - GRS.wrist.position.x 
		GRS[finger].joints[0].position.x = GRS.wrist.position.x + dx * Math.cos(GRS.wrist.pitch)
		GRS[finger].joints[0].position.y = GRS.wrist.position.y + d * Math.sin(GRS.wrist.pitch)
		GRS[finger].joints[0].spin.pitch = GRS.wrist.pitch

		GRS[finger].joints[0].object.position.set(GRS[finger].joints[0].position.x,GRS[finger].joints[0].position.y,GRS[finger].joints[0].position.z)
		
		bones = ["metacarpal","proximal","intermediate","distal"]
		var phi = finger_pitch(GRS[finger].pitch)
		var curr_joint = 0
		for(i=0;i<bones.length;i++)
		{
			// Joint
			if(i==2 && finger == "thumb")
				continue
			curr_joint++

			d = GRS[finger][bones[i]] * scale
			
			// Heading
			GRS[finger].joints[curr_joint].position.x = GRS[finger].joints[curr_joint-1].position.x + d * Math.sin(GRS[finger].joints[curr_joint-1].spin.heading)
			GRS[finger].joints[curr_joint].position.z = GRS[finger].joints[curr_joint-1].position.z + d * Math.cos(GRS[finger].joints[curr_joint-1].spin.heading)
			GRS[finger].joints[curr_joint].spin.heading = GRS[finger].joints[curr_joint-1].spin.heading

			//Pitch

			dx = GRS[finger].joints[curr_joint].position.x - GRS[finger].joints[curr_joint-1].position.x 
			GRS[finger].joints[curr_joint].position.x = GRS[finger].joints[curr_joint-1].position.x + dx * Math.cos(GRS[finger].joints[curr_joint-1].spin.pitch)
			GRS[finger].joints[curr_joint].position.y = GRS[finger].joints[curr_joint-1].position.y + d  * Math.sin(GRS[finger].joints[curr_joint-1].spin.pitch)
			GRS[finger].joints[curr_joint].spin.pitch = GRS[finger].joints[curr_joint-1].spin.pitch
			if(i>=0 && finger != "thumb")
				GRS[finger].joints[curr_joint].spin.pitch += phi 
			var x = GRS[finger].joints[curr_joint].position.x
			var y = GRS[finger].joints[curr_joint].position.y
			var z = GRS[finger].joints[curr_joint].position.z

			GRS[finger].joints[curr_joint].object.position.set(x,y,z)
			

			// continue
			// Bone

			var joint1 = GRS[finger].joints[curr_joint]
			var joint2 = GRS[finger].joints[curr_joint-1]
			GRS[finger].bones[curr_joint-1].position.x = joint1.position.x
			GRS[finger].bones[curr_joint-1].position.y = joint1.position.y
			GRS[finger].bones[curr_joint-1].position.z = joint1.position.z

			
			GRS[finger].bones[curr_joint-1].object.position.copy(joint1.position)
			GRS[finger].bones[curr_joint-1].object.lookAt(joint2.position)

			
		}
	}
}



function finger_pitch(phi)
{
	return (Math.PI - (-1/3*phi + Math.PI)) * -1
}

function draw_hand()
{
	// console.log(GRS)
	scene.add(GRS.wrist.object)
	//scene.add(GRS.index.joints[0].object)
	//return
	fingers = ["thumb","index","middle","ring","pinky"]
	for(i=0;i<fingers.length;i++)
	{
		finger = fingers[i]
		// console.log(finger)
		scene.add(GRS[finger].joints[0].object)
		bones = ["metacarpal","proximal","intermediate","distal"]
		
		// continue
		var curr_joint = 0
		for(j=0;j<bones.length;j++)
		{
			if(j==2 && finger == "thumb")
				continue
			curr_joint++
			//Joint
			scene.add(GRS[finger].joints[curr_joint].object)

			//Bone
			scene.add(GRS[finger].bones[curr_joint-1].object)


		}
	}
}

function animate(){
	requestAnimationFrame(animate)
	render()
	
	update()
}

function update(){
	redraw()
	// fe[0].position.x += 1
	var delta = clock.getDelta()

	// cylinder.rotation.x = rotation["pitch"] 
	// cylinder.rotation.y = rotation["heading"]
	// cylinder.rotation.z = rotation["roll"] 

	//console.log(delta)
	
	controls.update()
	stats.update()
}

function render(){
	renderer.render(scene,camera)
}

function sin(x){
	var alpha =  (x-90) * (Math.PI/180)
	return Math.sin(alpha)
}


function cos(x){
	var alpha = (x-90) * (Math.PI/180)
	return Math.cos(alpha)
}

function rad(x)
{
	return x * (Math.PI/180)
}

init()
animate()

var ws = new WebSocket ("ws://188.166.48.28:8080/websocket")
ws.onopen = function(){
	console.log("Done")
}

ws.onmessage = function(e)
{
	// console.log(e.data)
	if (e.data == "Init done")
		return 
	data = JSON.parse(e.data)
	car.rotation.x = data.wrist.heading
	car.rotation.y = data.wrist.pitch
	car.rotation.z = data.wrist.roll
	GRS.wrist.heading = data.wrist.heading * -1
	// GRS.wrist.pitch = data.wrist.pitch
	// GRS.index.pitch = data.index.pitch
	// GRS.middle.pitch = data.middle.pitch
	// GRS.ring.pitch = data.ring.pitch
	// GRS.pinky.pitch = data.pinky.pitch
	
	console.log(GRS.wrist.pitch)
}


ws.onclose = function()
{
	console.log("Closed")
}
</script>

{% end %}

{% block content %}
<div id="ThreeJS" style="z-index: 1; position: absolute; left:0px; top:0px"></div>

{% end %}